---
layout: post
title: "Simplifying NoSQL Database Integration with Jakarta NoSQL"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/dearrudam
author_github: https://github.com/dearrudam
seo-title: TITLE - OpenLiberty.io
seo-description: DESCRIPTION
blog_description: "DESCRIPTION"
open-graph-image: https://openliberty.io/img/twitter_card.jpg
open-graph-image-alt: Open Liberty Logo
---
= Simplifying NoSQL Database Integration with Jakarta NoSQL
Maximillian Arruda <https://github.com/dearrudam>
:imagesdir: /
:url-prefix:
:url-about: /


// // // // // // // //
// In the preceding section:
// Do not insert any blank lines between any of the lines.
//
// "open-graph-image" is set to OL logo. Whenever possible update this to a more appropriate/specific image (For example if present a image that is being used in the post). However, it
// can be left empty which will set it to the default
//
// "open-graph-image-alt" is a description of what is in the image (not a caption). When changing "open-graph-image" to
// a custom picture, you must provide a custom string for "open-graph-image-alt".
//
// Replace DESCRIPTION with a short summary (~60 words) of the release (a more succinct version of the first paragraph of the post).
//
// If adding image into the post add :
// -------------------------
// [.img_border_light]
// image::img/blog/FILE_NAME[IMAGE CAPTION ,width=70%,align="center"]
// -------------------------
// "[.img_border_light]" = This adds a faint grey border around the image to make its edges sharper. Use it around screenshots but not
// around diagrams. Then double check how it looks.
// There is also a "[.img_border_dark]" class which tends to work best with screenshots that are taken on dark backgrounds.
// Change "FILE_NAME" to the name of the image file. Also make sure to put the image into the right folder which is: img/blog
// change the "IMAGE CAPTION" to a couple words of what the image is
// // // // // // // //

Nowadays, it's normal to see cloud-native solutions dealing with a huge amount of information. In this scenario, the NoSQL databases are getting a huge relevant position, but dealing with many NoSQL solutions from many different vendors is very difficult.

In terms of dealing with relational databases, there's no doubt that JPA specification is a well-established API in the Java world, but what if there's a well-defined way, pretty similar to JPA, to work with NoSQL with Java?

In this blogpost, let's discuss and learn why Jakarta NoSQL can make easier the developer's life regarding the Java NoSQL database integration.


== NoSQL Overview

For some, NoSQL stands for "Not Only SQL", for others stands for "Non-SQL" or "Not Relational" but one thing we may agree on: NoSQL databases are different from SQL databases.

Unlike the traditional SQL databases that use tabular relations to store and retrieve data with predefined schemas, NoSQL Databases provide mechanisms for retrieving and storing unstructured and semi-structured data (non-relational). Compared to relational databases, NoSQL databases have better performance and high levels of availability and scalability, which means, they are designed to scale horizontally by distributing data across many servers, making them well-suited for handling large and growing datasets. As they are becoming more popular in several industries, such as finance and streaming, the number of users and database vendors is growing as well.

There are many NoSQL databases types, each one is designed to handle a specific set of workloads and data modeling needs.

== Different types of NoSQL Database

Many NoSQL databases types exist, but let's focus on the most famous types: Key-Value, Document, Column, and Graph databases;

=== Key-Value Databases

These are the simplest storage types between the NoSQL databases. Key-value NoSQL databases store data as a collection of key-value pairs, making them ideal for high-speed data retrieval by using keys. This database type has a structure that resembles a `java.util.Map` API from the Java language where values are mapped to keys. Key-value databases are often used for caching, session management, and message queues.

[.img_border_light]
image::/img/blog/key-value-nosql.png[Key-value database type,align="center" width=25%,height=25%]


Currently on the market, there are many vendors that provide solutions for this NoSQL database type. Some of them are: *Amazon DynamoDB*, *Redis*, *Hazelcast*, *Memcached*, among others. The latter three mentioned here are open source technologies.

=== Document Databases

The Document NoSQL databases are designed to store, retrieve, and manage documents with a minimally defined structure, such as the XML and JSON formats. A document without a predefined structure, in other words, is a data model that may be composed of numerous fields with different kinds of data, including documents inside other documents. For practitioners of Domain-Driven Development (DDD), this data structure may be handled as aggregates managing their derived entities in a hierarchical structure. Document databases are well-suited for managing unstructured data, such as user profiles, product catalogs, or content management systems.

[.img_border_light]
image::/img/blog/document-nosql.png[Document database type,align="center" width=25%,height=25%]

There are many vendors that provides solutions for this NoSQL database type on the market. Some of them are: *MongoDB*, *Couchbase*, *Elastic*, *Oracle NoSQL Database*, among others.

=== Column Databases

The Column NoSQL databases (also known as column-oriented or wide-column databases) store data as columns instead of rows as usual in the traditional relational databases world, making them ideal for handling large amounts of data and complex queries once compared with other NoSQL database types. These databases are designed and optimized for storing large amounts of structured, semi-structured, and unstructured data with a flexible schema, supporting high levels of concurrency and scalability. Wide-column databases are often used for analytics, content management, and data warehousing.

[.img_border_light]
image::/img/blog/column-nosql.png[Column database type,align="center" width=25%,height=25%]

Examples of Column databases on the market include *Apache HBase*, *Apache Cassandra*, *Scylla*, *Azure Cosmos DB*, and many others. The first two mentioned here are open source technologies.

=== Graph Databases

The Graph NoSQL database type is designed and optimized for storing and querying data with complex relationships. In this approach, data is managed as a graph where entities can be represented as node and edges, making them well-suited for managing complex relationship and hierarchies. The graph data resembles the graph of objects in the Oriented-Object programming paradigm. Graph NoSQL database solutions can fit well in scenarios that require fast querying of highly interconnected data, such as social networks, recommendation engines, and fraud detection systems.

[.img_border_light]
image::/img/blog/graph-nosql.png[Graph database type,align="center" width=25%,height=25%]

There are several graph database engines of many vendors to choose from, including *Neo4J*, *Arango DB*, *OrientDB*, *JanusGraph*, among others. The last one mentioned is open source technologies.

=== NoSQL integration challenges

Nowadays, depending on the requirements of the solutions that need to be delivered, integrating into these NoSQL databases will be inevitable, so we'll need to be able to deal with many NoSQL solutions from many different vendors. Having said that, many challenges raise to us, like:

* The high cognitive load necessary when choosing a NoSQL database for their solutions;
* The Learning curve of the database APIs of the chosen NoSQL databases;
* The time spent on the changes to the existent codebase;
* The possibility to make complex the onboarding of new coming developers to the team;

Furthermore, today in the cloud era where we pay as we use, we are always looking for save resources and costs, which means, the possibility to switch out a database becomes true. In addition to the challenges above, the solution that integrates with these NoSQL solutions needs to be able to keep a concise business logic isolation from the persistence layer because probably such a layer will be changed or replaced.

According to https://db-engines.com/en/ranking[DB-Engines Ranking], an initiative from DB-Engines website that lists DBMS ranked by popularity, on February 2024 we can figure out that there are over **180 non-relational/NoSQL databases on the market**. In the chart below we can see the ranking of database engines per database category:

[.img_border_light] 
image::/img/blog/db-engine-ranking-2024-02.png["Number of engines per category, February 2024",width=70%,align="center"]

In order to solve these mentioned challenges, let's take a look at the past not so far away, we can see a similar challenge involving Relational database and Java integration. The JDBC (Java Database connectivity) was created to standardize the way Java integrates with Relational databases, and then, to get closer to the OOP paradigm using the ORM pattern, Jakarta Persistence specification comes to facilitate the work with many Relational databases engines and vendors.

Okay, based on this information about the solution using Jakarta Persistence, wouldn't it be interesting to have a similar API to work with NoSQL?

Say hello to Jakarta NoSQL and Jakarta Data! Both came to simplify the NoSQL integration with many vendors, making data retrieval and manipulation more intuitive and developer-friendly.

== Jakarta NoSQL

Jakarta NoSQL is a Jakarta EE specification designed to easily integrate Java and NoSQL databases. It uses common annotations and specific APIs for the following NoSQL database types: key-value, column, and document databases.

== Jakarta Data

Jakarta Data is a Jakarta EE specification that provides a unified API for simplified data access across different types of databases, including both relational and NoSQL databases. This specification achieves this by introducing concepts like Repositories and custom query methods, making data retrieval and manipulation more intuitive and developer-friendly.

[NOTE]
Jakarta Data will be included in Jakarta EE 11 - https://jakarta.ee/specifications/data/1.0/

== Eclipse JNoSQL - A Reference Implementation

A Jakarta EE Specification doesn't solve the problem by themselves alone, it's necessary an implementation.

Each Jakarta EE Specification use to have at least one implementation. Having one implementation means that the specification is implementable, opening the opportunity for companies and community to provide their own implementation, powering the Jakarta EE users with various and powerful tooling.

Example of reference implementations (RI):

* Hibernate for Jakarta Persistence 3.1 specification;
* Jersey for Jakarta RESTFul Web Services 3.1 specification;
* Glassfish for Jakarta Servlet 6.0 specification;
* Weld for Jakarta Context And Dependency Injection (CDI) 4.0 specification;
* and so on...

*Eclipse JNoSQL* is a compatible implementation of the *Jakarta NoSQL* and *Jakarta Data* specification, a framework that streamlines the integration of Java applications with NoSQL databases. It uses the power of the Jakarta Contexts and Dependency Injection (CDI) specification as an engine, making it compatible with both Jakarta EE vendors and Eclipse MicroProfile.

Currently, the Jakarta NoSQL doesn't define an API for Graph database types but Eclipse JNoSQL provides a Graph template to explore the specific behavior of this NoSQL type by using Apache TinkerPop as a communication layer. In summary, Eclipse JNoSQL covers four NoSQL database types: key-value, column, document and graph databases.

For now, Eclipse JNoSQL supports about https://www.jnosql.org/docs/supported_dbs.html[30 NoSQL databases].

=== Motivation

In the snipped codes below we can see a typical behavior among Document NoSQL databases: a document creation and adding a property into the created document:

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/mongodb.png[MongoDB ,align="left" width=25%,height=25%]
[source, java]
----
Document document = new Document();
document.append(name, value);
----
****

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/ArangoDB.png[Arango DB,align="left" width=25%,height=25%]
[source, java]
----
BaseDocument baseDocument = new BaseDocument();
baseDocument.addAttribute(name, value);
----
****

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/couchbase.svg[Couchbase,align="left" width=25%,height=25%]
[source, java]
----
JsonObject jsonObject = JsonObject.create();
jsonObject.put(name, value);
----
****

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/orientdb.png[Orient Project,align="left" width=25%,height=25%]
[source, java]
----
ODocument document = new ODocument("collection");
document.field(name, value);
----
****

Eclipse JNoSQL provides a common API that allows to use several database types without vendor lock-in providing a low cognitive load to learn a new API. For example, on the Document API, it's possible to switch between MongoDB and ArangoDB as needed by using CoC (Convention Over Configuration).

[.img_border_light]
****
image::https://jnosql.github.io/images/home_logo.png[Orient Project,align="left" width=25%,height=25%]
[source, java]
----
DocumentEntity entity = DocumentEntity.of("collection");
entity.add(name, value);
----
****

Also, we can explore the Jakarta NoSQL annotations here:

[source, java]
----
import jakarta.nosql.Entity;
import jakarta.nosql.Id;
import jakarta.nosql.Column;

@Entity
public class Book {

    @Id
    private String isbn;

    @Column
    private String title;

    @Column
    private String author;

    @Convert(YearConverter.class)
    @Column
    private Year year;

}
----

If the project is using Java 17 or above, Eclipse JNoSQL allows us to use Java Records as entities:

[source, java]
----
import jakarta.nosql.Entity;
import jakarta.nosql.Id;
import jakarta.nosql.Column;

@Entity
public record Book(@Id String isbn,
                   @Column("title") String title,
                   @Column("author") String author,
                   @Convert(YearConverter.class) @Column("year") Year year,
                   @Column("edition") int edition) {

}

----

Last but not least, Eclipse JNoSQL as a Jakarta Data implementation allows us to create repositories, offering a feature based on the Domain-Driven Development (DDD) Repository pattern, helping developers to bring the code near to the business (domain centric) instead of the database semantics.

[source,java]
----
import jakarta.data.page.Page;
import jakarta.data.page.Pageable;
import jakarta.data.repository.Delete;
import jakarta.data.repository.Repository;
import jakarta.data.repository.PageableRepository;
import jakarta.data.repository.Query;
import jakarta.data.repository.Param;
import jakarta.data.repository.Save;

@Repository
public interface Garage extends PageableRepository<Car,String>{

    @Save
    Car park(Car car);

    @Delete
    Car unPark(Car car);

    @Query("select * from Car where driver.name = @name")
    Set<Car> findByDriver(@Param("name") String name);

    Page<Car> findByColor(Color color, Pageable pageable);

}
----

=== Eclipse JNoSQL Goals

Beyond being a Jakarta NoSQL and Jakarta Data implementation, such framework intents to reaching out these goals:

* Increase productivity performing common NoSQL operations
* Use of Convention Over Configuration
* Rich Object Mapping integrated with Contexts and Dependency Injection (CDI)
* Java-based Query and Fluent-API
* Persistence lifecycle events
* Low-level mapping using Standard NoSQL APIs
* Specific template API to each NoSQL category
* Annotation-oriented using JPA-like naming when it makes sense
* Extensible to explore the particular behavior of a NoSQL database
* Explore the popularity of Apache TinkerPop in Graph API

After getting an overview about the Jakarta NoSQL, Jakarta Data, and the Eclipse JNoSQL, let's explore on a hands-on approach how we could use and forest these features in an interesting project, managing and querying data from NoSQL databases and switching between NoSQL databases as needed.

== Meeting the JNopo game

*JNopo* game is a Java version of the famous the _Rock, Paper, and Scissors_ game. This game consists of a battle of two players where each one chooses a movement between rock, paper, or scissors. To illustrate the game logic, let's suppose that a _Player A_ will play with a _Player B_ and, in this case:

* If _Player A_ chooses _ROCK_ and _Player B_ chooses _SCISSORS_ then _Player A_ wins the game.
* If _Player A_ chooses _PAPER_ and _Player B_ chooses _ROCK_ then _Player A_ wins the game.
* If _Player A_ chooses _SCISSORS_ and _Player B_ chooses _PAPER_ then _Player A_ wins the game.
* If _Player A_ and _Player B_ choose the same movement then no one wins, and a tied game happens.

In the sequence diagram below we can illustrate the default behavior of the JNopo game:

[.img_border_light]
image::/img/blog/jnopo-sequence-diagram-without-persistence.gif[JNopo Sequence Diagram, align="center" width=60%]

*JNopo* is a game implemented using Jakarta EE Specifications, which means, it's compatible with Jakarta EE and MicroProfile runtimes, and in our case we're using https://openliberty.io/[Open Liberty] 23.0.0.10.

The architecture for this application is composed by two components:

* The web page where the players interact to the game;

* The back-end where the game matches are managed;

In the image below we can see the system design of the JNopo game:

[.img_border_light]
image::/img/blog/jnopo-architecture-without-persistence.png[JNopo Architecture Diagram, align="center" width=60%]

== It's time to have fun! Let's play the JNopo game!

Yeah! It's time have fun playing *JNopo*!

Clone the https://github.com/OpenLiberty/sample-jakartaNoSQL-game[Git repository]:

[source, bash]
----
git clone https://github.com/OpenLiberty/sample-jakartaNoSQL-game.git

cd sample-jakartaNoSQL-game
----

Navigate to the `start` directory. This directory contains the starting project that we'll work through this blogpost.

[source, bash]
----
cd start
----

It's a Maven project using Maven Wrapper plugin, which means, you just need to have the *JDK 21* installed in your machine to build and/or run the application.

This project is ready to run with the https://openliberty.io/[Open Liberty] then you just need to perform the following command:

* For Mac or Linux:

+
[source, bash]
----
./mvnw liberty:dev
----

* For Windows:

+
[source, powershell]
----
mvnw.cmd liberty:dev
----

This will install all required dependencies and start the default server.

Now, if everything works, you can play the game by accessing the following URL address:

[source, curl]
----
http://localhost:9080/jakarta-nosql-game/
----

To play the game locally you just need to open two browsers tabs/windows pointing to the same URL address.

== Challenge time: Winner ranking

This blog post will become more interesting: why not to challenge us to learn, create and improve our knowledge and practical software development skills, don't you? That's we're going to do: let's make JNopo provides a winner ranking!

This challenge is an amazing opportunity to learn and explore how to use Jakarta NoSQL and Jakarta Data to simplify NoSQL integration with Java applications.

To get a winner ranking, JNopo needs to persist the game matches results and then summarize the results composing the ranking. To expose this ranking, it's expected that the application provides a REST API like below:

[source, bash]
----
curl -X GET \
  -H 'Accept: application/json' \
  http://localhost:9080/jakarta-nosql-game/api/playoffs/ranking
----

The expected winner ranking structure should follow the JSON below:

[source, json]
----
{
  "data" : {
    "Max": 2,
    "Fabio": 1
  }
}
----

I said, it'll be interesting!

=== Setup dependencies

=== Setup Eclipse JNoSQL

=== Implementing the persistence layer

=== Implementing the Winner Ranking

== Takeaways

== Nice work! Where to next?

== References

// // // // // // // //
// Resources Links
//
// TODO create a resources list
//
// article: Introduction to NoSQL Database by Rama Krishna Panguluri
// link: https://dzone.com/articles/introduction-to-nosql-database-1
//
// article: Jakarta NoSQL 1.0.0-b5: How To Make Your Life Easier Around Enterprise Java and NoSQL Databases by Otavio Santana
// https://dzone.com/articles/jakarta-nosql-100-b5-how-to-make-your-life-easier
//
// article: Mastering Java Persistence: Best Practices for Cloud-Native Applications and Modernization by Otavio Santana
// https://dzone.com/articles/mastering-java-persistence-best-practices-for-clou
//
// article: Eclipse JNoSQL 1.0.0: Streamlining Java and NoSQL Integration With New Features and Bug Fixes by Otavio Santana
// https://dzone.com/articles/eclipse-jnosql-100-streamlining-java-and-nosql-int
//
// article: Eclipse JNoSQL 1.0.2: Empowering Java With NoSQL Database Flexibility by Otavio Santana
// https://dzone.com/articles/eclipse-jnosql-102-empowering-java-with-nosql-data
//
// article: Exploring the New Eclipse JNoSQL Version 1.1.0: A Dive Into Oracle NoSQL by Otavio Santana
// https://dzone.com/articles/exploring-the-new-eclipse-jnosql-version-110-a-div
//
// book: Persistence Best Practices for Java Applications by Otavio Santana and Karina Varela
// link: https://www.amazon.com/Persistence-Best-Practices-Java-Applications/dp/1837631271/
//
// article: Getting Started - Accessing Oracle NoSQL Database using Jakarta NoSQL by Dario VEGA
// https://blogs.oracle.com/nosql/post/getting-started-accessing-oracle-nosql-database-using-jakarta-nosql
//
// article: Simplifying data access with MySQL and Jakarta Data by Ivar Grimstad
// https://blogs.oracle.com/javamagazine/post/jakarta-data-mysql
//
// website: Eclipse JNoSQL
// https://jnosql.org
//
//


// // // // // // // //
// LINKS
//
// OpenLiberty.io site links:
// link:/guides/microprofile-rest-client.html[Consuming RESTful Java microservices]
//
// Off-site links:
// link:https://openapi-generator.tech/docs/installation#jar[Download Instructions]
//
// // // // // // // //
